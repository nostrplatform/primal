{"version":3,"file":"RLGGFAYQ-2a48be09.js","sources":["../../node_modules/@solid-primitives/event-listener/dist/index.js","../../node_modules/@kobalte/core/dist/chunk/FKUFPCQ6.jsx","../../node_modules/@kobalte/core/dist/chunk/RLGGFAYQ.jsx"],"sourcesContent":["import { tryOnCleanup, entries, createCallbackStack, asArray, access, keys } from '@solid-primitives/utils';\nimport { createEffect, createRenderEffect, createSignal, onCleanup } from 'solid-js';\nimport { isServer } from 'solid-js/web';\n\n// src/eventListener.ts\nfunction makeEventListener(target, type, handler, options) {\n  target.addEventListener(type, handler, options);\n  return tryOnCleanup(target.removeEventListener.bind(target, type, handler, options));\n}\nfunction createEventListener(targets, type, handler, options) {\n  if (isServer)\n    return;\n  const attachListeners = () => {\n    asArray(access(targets)).forEach((el) => {\n      if (el)\n        asArray(access(type)).forEach((type2) => makeEventListener(el, type2, handler, options));\n    });\n  };\n  if (typeof targets === \"function\")\n    createEffect(attachListeners);\n  else\n    createRenderEffect(attachListeners);\n}\nfunction createEventSignal(target, type, options) {\n  if (isServer) {\n    return () => void 0;\n  }\n  const [lastEvent, setLastEvent] = createSignal();\n  createEventListener(target, type, setLastEvent, options);\n  return lastEvent;\n}\nvar eventListener = (target, props) => {\n  createEffect(() => {\n    const [type, handler, options] = props();\n    makeEventListener(target, type, handler, options);\n  });\n};\nfunction createEventListenerMap(targets, handlersMap, options) {\n  if (isServer) {\n    return;\n  }\n  for (const [eventName, handler] of entries(handlersMap)) {\n    if (handler)\n      createEventListener(targets, eventName, handler, options);\n  }\n}\nvar attachPropListeners = (target, props) => {\n  keys(props).forEach((attr) => {\n    if (attr.startsWith(\"on\") && typeof props[attr] === \"function\")\n      makeEventListener(target, attr.substring(2).toLowerCase(), props[attr]);\n  });\n};\nvar WindowEventListener = (props) => {\n  if (isServer)\n    return null;\n  attachPropListeners(window, props);\n};\nvar DocumentEventListener = (props) => {\n  if (isServer)\n    return null;\n  attachPropListeners(document, props);\n};\nfunction makeEventListenerStack(target, options) {\n  if (isServer) {\n    return [() => () => void 0, () => void 0];\n  }\n  const { push, execute } = createCallbackStack();\n  return [\n    (type, handler, overwriteOptions) => {\n      const clear = makeEventListener(target, type, handler, overwriteOptions ?? options);\n      push(clear);\n      return clear;\n    },\n    onCleanup(execute)\n  ];\n}\n\n// src/callbackWrappers.ts\nvar preventDefault = (callback) => (e) => {\n  e.preventDefault();\n  callback(e);\n};\nvar stopPropagation = (callback) => (e) => {\n  e.stopPropagation();\n  callback(e);\n};\nvar stopImmediatePropagation = (callback) => (e) => {\n  e.stopImmediatePropagation();\n  callback(e);\n};\n\nexport { DocumentEventListener, WindowEventListener, createEventListener, createEventListenerMap, createEventSignal, eventListener, makeEventListener, makeEventListenerStack, preventDefault, stopImmediatePropagation, stopPropagation };\n","// src/primitives/create-collection/create-collection.ts\nimport { access } from \"@kobalte/utils\";\nimport { createMemo } from \"solid-js\";\n\n// src/primitives/create-collection/utils.ts\nimport { isNumber, isString } from \"@kobalte/utils\";\nfunction buildNodes(params) {\n  let index = params.startIndex ?? 0;\n  const level = params.startLevel ?? 0;\n  const nodes = [];\n  const getKey = (data) => {\n    if (data == null) {\n      return \"\";\n    }\n    const _getKey = params.getKey ?? \"key\";\n    const dataKey = isString(_getKey) ? data[_getKey] : _getKey(data);\n    return dataKey != null ? String(dataKey) : \"\";\n  };\n  const getTextValue = (data) => {\n    if (data == null) {\n      return \"\";\n    }\n    const _getTextValue = params.getTextValue ?? \"textValue\";\n    const dataTextValue = isString(_getTextValue) ? data[_getTextValue] : _getTextValue(data);\n    return dataTextValue != null ? String(dataTextValue) : \"\";\n  };\n  const getDisabled = (data) => {\n    if (data == null) {\n      return false;\n    }\n    const _getDisabled = params.getDisabled ?? \"disabled\";\n    return (isString(_getDisabled) ? data[_getDisabled] : _getDisabled(data)) ?? false;\n  };\n  const getSectionChildren = (data) => {\n    if (data == null) {\n      return void 0;\n    }\n    if (isString(params.getSectionChildren)) {\n      return data[params.getSectionChildren];\n    }\n    return params.getSectionChildren?.(data);\n  };\n  for (const data of params.dataSource) {\n    if (isString(data) || isNumber(data)) {\n      nodes.push({\n        type: \"item\",\n        rawValue: data,\n        key: String(data),\n        textValue: String(data),\n        disabled: getDisabled(data),\n        level,\n        index\n      });\n      index++;\n      continue;\n    }\n    if (getSectionChildren(data) != null) {\n      nodes.push({\n        type: \"section\",\n        rawValue: data,\n        key: \"\",\n        // not applicable here\n        textValue: \"\",\n        // not applicable here\n        disabled: false,\n        // not applicable here\n        level,\n        index\n      });\n      index++;\n      const sectionChildren = getSectionChildren(data) ?? [];\n      if (sectionChildren.length > 0) {\n        const childNodes = buildNodes({\n          dataSource: sectionChildren,\n          getKey: params.getKey,\n          getTextValue: params.getTextValue,\n          getDisabled: params.getDisabled,\n          getSectionChildren: params.getSectionChildren,\n          startIndex: index,\n          startLevel: level + 1\n        });\n        nodes.push(...childNodes);\n        index += childNodes.length;\n      }\n    } else {\n      nodes.push({\n        type: \"item\",\n        rawValue: data,\n        key: getKey(data),\n        textValue: getTextValue(data),\n        disabled: getDisabled(data),\n        level,\n        index\n      });\n      index++;\n    }\n  }\n  return nodes;\n}\n\n// src/primitives/create-collection/create-collection.ts\nfunction createCollection(props, deps = []) {\n  return createMemo(() => {\n    const nodes = buildNodes({\n      dataSource: access(props.dataSource),\n      getKey: access(props.getKey),\n      getTextValue: access(props.getTextValue),\n      getDisabled: access(props.getDisabled),\n      getSectionChildren: access(props.getSectionChildren)\n    });\n    for (let i = 0; i < deps.length; i++)\n      deps[i]();\n    return props.factory(nodes);\n  });\n}\n\nexport {\n  createCollection\n};\n","import {\n  createCollection\n} from \"./FKUFPCQ6.jsx\";\nimport {\n  useLocale\n} from \"./LR7LBJN3.jsx\";\nimport {\n  createControllableSignal\n} from \"./FN6EICGO.jsx\";\n\n// src/selection/types.ts\nvar Selection = class _Selection extends Set {\n  anchorKey;\n  currentKey;\n  constructor(keys, anchorKey, currentKey) {\n    super(keys);\n    if (keys instanceof _Selection) {\n      this.anchorKey = anchorKey || keys.anchorKey;\n      this.currentKey = currentKey || keys.currentKey;\n    } else {\n      this.anchorKey = anchorKey;\n      this.currentKey = currentKey;\n    }\n  }\n};\n\n// src/selection/create-multiple-selection-state.ts\nimport { access, mergeDefaultProps } from \"@kobalte/utils\";\nimport { createEffect, createMemo, createSignal } from \"solid-js\";\n\n// src/selection/create-controllable-selection-signal.ts\nfunction createControllableSelectionSignal(props) {\n  const [_value, setValue] = createControllableSignal(props);\n  const value = () => _value() ?? new Selection();\n  return [value, setValue];\n}\n\n// src/selection/utils.ts\nimport { isAppleDevice, isMac } from \"@kobalte/utils\";\nfunction isNonContiguousSelectionModifier(e) {\n  return isAppleDevice() ? e.altKey : e.ctrlKey;\n}\nfunction isCtrlKeyPressed(e) {\n  if (isMac()) {\n    return e.metaKey;\n  }\n  return e.ctrlKey;\n}\nfunction convertSelection(selection) {\n  return new Selection(selection);\n}\nfunction isSameSelection(setA, setB) {\n  if (setA.size !== setB.size) {\n    return false;\n  }\n  for (const item of setA) {\n    if (!setB.has(item)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/selection/create-multiple-selection-state.ts\nfunction createMultipleSelectionState(props) {\n  const mergedProps = mergeDefaultProps(\n    {\n      selectionMode: \"none\",\n      selectionBehavior: \"toggle\"\n    },\n    props\n  );\n  const [isFocused, setFocused] = createSignal(false);\n  const [focusedKey, setFocusedKey] = createSignal();\n  const selectedKeysProp = createMemo(() => {\n    const selection = access(mergedProps.selectedKeys);\n    if (selection != null) {\n      return convertSelection(selection);\n    }\n    return selection;\n  });\n  const defaultSelectedKeys = createMemo(() => {\n    const defaultSelection = access(mergedProps.defaultSelectedKeys);\n    if (defaultSelection != null) {\n      return convertSelection(defaultSelection);\n    }\n    return new Selection();\n  });\n  const [selectedKeys, _setSelectedKeys] = createControllableSelectionSignal({\n    value: selectedKeysProp,\n    defaultValue: defaultSelectedKeys,\n    onChange: (value) => mergedProps.onSelectionChange?.(value)\n  });\n  const [selectionBehavior, setSelectionBehavior] = createSignal(access(mergedProps.selectionBehavior));\n  const selectionMode = () => access(mergedProps.selectionMode);\n  const disallowEmptySelection = () => access(mergedProps.disallowEmptySelection) ?? false;\n  const setSelectedKeys = (keys) => {\n    if (access(mergedProps.allowDuplicateSelectionEvents) || !isSameSelection(keys, selectedKeys())) {\n      _setSelectedKeys(keys);\n    }\n  };\n  createEffect(() => {\n    const selection = selectedKeys();\n    if (access(mergedProps.selectionBehavior) === \"replace\" && selectionBehavior() === \"toggle\" && typeof selection === \"object\" && selection.size === 0) {\n      setSelectionBehavior(\"replace\");\n    }\n  });\n  createEffect(() => {\n    setSelectionBehavior(access(mergedProps.selectionBehavior) ?? \"toggle\");\n  });\n  return {\n    selectionMode,\n    disallowEmptySelection,\n    selectionBehavior,\n    setSelectionBehavior,\n    isFocused,\n    setFocused,\n    focusedKey,\n    setFocusedKey,\n    selectedKeys,\n    setSelectedKeys\n  };\n}\n\n// src/selection/create-type-select.ts\nimport { access as access2 } from \"@kobalte/utils\";\nimport { createSignal as createSignal2 } from \"solid-js\";\nfunction createTypeSelect(props) {\n  const [search, setSearch] = createSignal2(\"\");\n  const [timeoutId, setTimeoutId] = createSignal2(-1);\n  const onKeyDown = (e) => {\n    if (access2(props.isDisabled)) {\n      return;\n    }\n    const delegate = access2(props.keyboardDelegate);\n    const manager = access2(props.selectionManager);\n    if (!delegate.getKeyForSearch) {\n      return;\n    }\n    const character = getStringForKey(e.key);\n    if (!character || e.ctrlKey || e.metaKey) {\n      return;\n    }\n    if (character === \" \" && search().trim().length > 0) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    let newSearch = setSearch((prev) => prev + character);\n    let key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);\n    if (key == null && isAllSameLetter(newSearch)) {\n      newSearch = newSearch[0];\n      key = delegate.getKeyForSearch(newSearch, manager.focusedKey()) ?? delegate.getKeyForSearch(newSearch);\n    }\n    if (key != null) {\n      manager.setFocusedKey(key);\n      props.onTypeSelect?.(key);\n    }\n    clearTimeout(timeoutId());\n    setTimeoutId(window.setTimeout(() => setSearch(\"\"), 500));\n  };\n  return {\n    typeSelectHandlers: {\n      onKeyDown\n    }\n  };\n}\nfunction getStringForKey(key) {\n  if (key.length === 1 || !/^[A-Z]/i.test(key)) {\n    return key;\n  }\n  return \"\";\n}\nfunction isAllSameLetter(search) {\n  return search.split(\"\").every((letter) => letter === search[0]);\n}\n\n// src/selection/create-selectable-collection.ts\nimport {\n  access as access3,\n  callHandler,\n  createEventListener,\n  focusWithoutScrolling,\n  getFocusableTreeWalker,\n  scrollIntoView\n} from \"@kobalte/utils\";\nimport {\n  createEffect as createEffect2,\n  createMemo as createMemo2,\n  mergeProps,\n  on,\n  onMount\n} from \"solid-js\";\nfunction createSelectableCollection(props, ref, scrollRef) {\n  const defaultProps = {\n    selectOnFocus: () => access3(props.selectionManager).selectionBehavior() === \"replace\"\n  };\n  const mergedProps = mergeProps(defaultProps, props);\n  const finalScrollRef = () => scrollRef?.() ?? ref();\n  const { direction } = useLocale();\n  let scrollPos = { top: 0, left: 0 };\n  createEventListener(\n    () => !access3(mergedProps.isVirtualized) ? finalScrollRef() : void 0,\n    \"scroll\",\n    () => {\n      const scrollEl = finalScrollRef();\n      if (!scrollEl) {\n        return;\n      }\n      scrollPos = {\n        top: scrollEl.scrollTop,\n        left: scrollEl.scrollLeft\n      };\n    }\n  );\n  const { typeSelectHandlers } = createTypeSelect({\n    isDisabled: () => access3(mergedProps.disallowTypeAhead),\n    keyboardDelegate: () => access3(mergedProps.keyboardDelegate),\n    selectionManager: () => access3(mergedProps.selectionManager)\n  });\n  const orientation = () => access3(mergedProps.orientation) ?? \"vertical\";\n  const onKeyDown = (e) => {\n    callHandler(e, typeSelectHandlers.onKeyDown);\n    if (e.altKey && e.key === \"Tab\") {\n      e.preventDefault();\n    }\n    const refEl = ref();\n    if (!refEl?.contains(e.target)) {\n      return;\n    }\n    const manager = access3(mergedProps.selectionManager);\n    const selectOnFocus = access3(mergedProps.selectOnFocus);\n    const navigateToKey = (key) => {\n      if (key != null) {\n        manager.setFocusedKey(key);\n        if (e.shiftKey && manager.selectionMode() === \"multiple\") {\n          manager.extendSelection(key);\n        } else if (selectOnFocus && !isNonContiguousSelectionModifier(e)) {\n          manager.replaceSelection(key);\n        }\n      }\n    };\n    const delegate = access3(mergedProps.keyboardDelegate);\n    const shouldFocusWrap = access3(mergedProps.shouldFocusWrap);\n    const focusedKey = manager.focusedKey();\n    switch (e.key) {\n      case (orientation() === \"vertical\" ? \"ArrowDown\" : \"ArrowRight\"): {\n        if (delegate.getKeyBelow) {\n          e.preventDefault();\n          let nextKey;\n          if (focusedKey != null) {\n            nextKey = delegate.getKeyBelow(focusedKey);\n          } else {\n            nextKey = delegate.getFirstKey?.();\n          }\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getFirstKey?.(focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case (orientation() === \"vertical\" ? \"ArrowUp\" : \"ArrowLeft\"): {\n        if (delegate.getKeyAbove) {\n          e.preventDefault();\n          let nextKey;\n          if (focusedKey != null) {\n            nextKey = delegate.getKeyAbove(focusedKey);\n          } else {\n            nextKey = delegate.getLastKey?.();\n          }\n          if (nextKey == null && shouldFocusWrap) {\n            nextKey = delegate.getLastKey?.(focusedKey);\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case (orientation() === \"vertical\" ? \"ArrowLeft\" : \"ArrowUp\"): {\n        if (delegate.getKeyLeftOf) {\n          e.preventDefault();\n          const isRTL = direction() === \"rtl\";\n          let nextKey;\n          if (focusedKey != null) {\n            nextKey = delegate.getKeyLeftOf(focusedKey);\n          } else {\n            nextKey = isRTL ? delegate.getFirstKey?.() : delegate.getLastKey?.();\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case (orientation() === \"vertical\" ? \"ArrowRight\" : \"ArrowDown\"): {\n        if (delegate.getKeyRightOf) {\n          e.preventDefault();\n          const isRTL = direction() === \"rtl\";\n          let nextKey;\n          if (focusedKey != null) {\n            nextKey = delegate.getKeyRightOf(focusedKey);\n          } else {\n            nextKey = isRTL ? delegate.getLastKey?.() : delegate.getFirstKey?.();\n          }\n          navigateToKey(nextKey);\n        }\n        break;\n      }\n      case \"Home\":\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          const firstKey = delegate.getFirstKey(\n            focusedKey,\n            isCtrlKeyPressed(e)\n          );\n          if (firstKey != null) {\n            manager.setFocusedKey(firstKey);\n            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === \"multiple\") {\n              manager.extendSelection(firstKey);\n            } else if (selectOnFocus) {\n              manager.replaceSelection(firstKey);\n            }\n          }\n        }\n        break;\n      case \"End\":\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          const lastKey = delegate.getLastKey(focusedKey, isCtrlKeyPressed(e));\n          if (lastKey != null) {\n            manager.setFocusedKey(lastKey);\n            if (isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode() === \"multiple\") {\n              manager.extendSelection(lastKey);\n            } else if (selectOnFocus) {\n              manager.replaceSelection(lastKey);\n            }\n          }\n        }\n        break;\n      case \"PageDown\":\n        if (delegate.getKeyPageBelow && focusedKey != null) {\n          e.preventDefault();\n          const nextKey = delegate.getKeyPageBelow(focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"PageUp\":\n        if (delegate.getKeyPageAbove && focusedKey != null) {\n          e.preventDefault();\n          const nextKey = delegate.getKeyPageAbove(focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"a\":\n        if (isCtrlKeyPressed(e) && manager.selectionMode() === \"multiple\" && access3(mergedProps.disallowSelectAll) !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case \"Escape\":\n        if (!e.defaultPrevented) {\n          e.preventDefault();\n          if (!access3(mergedProps.disallowEmptySelection)) {\n            manager.clearSelection();\n          }\n        }\n        break;\n      case \"Tab\": {\n        if (!access3(mergedProps.allowsTabNavigation)) {\n          if (e.shiftKey) {\n            refEl.focus();\n          } else {\n            const walker = getFocusableTreeWalker(refEl, { tabbable: true });\n            let next;\n            let last;\n            do {\n              last = walker.lastChild();\n              if (last) {\n                next = last;\n              }\n            } while (last);\n            if (next && !next.contains(document.activeElement)) {\n              focusWithoutScrolling(next);\n            }\n          }\n          break;\n        }\n      }\n    }\n  };\n  const onFocusIn = (e) => {\n    const manager = access3(mergedProps.selectionManager);\n    const delegate = access3(mergedProps.keyboardDelegate);\n    const selectOnFocus = access3(mergedProps.selectOnFocus);\n    if (manager.isFocused()) {\n      if (!e.currentTarget.contains(e.target)) {\n        manager.setFocused(false);\n      }\n      return;\n    }\n    if (!e.currentTarget.contains(e.target)) {\n      return;\n    }\n    manager.setFocused(true);\n    if (manager.focusedKey() == null) {\n      const navigateToFirstKey = (key) => {\n        if (key == null) {\n          return;\n        }\n        manager.setFocusedKey(key);\n        if (selectOnFocus) {\n          manager.replaceSelection(key);\n        }\n      };\n      const relatedTarget = e.relatedTarget;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {\n        navigateToFirstKey(\n          manager.lastSelectedKey() ?? delegate.getLastKey?.()\n        );\n      } else {\n        navigateToFirstKey(\n          manager.firstSelectedKey() ?? delegate.getFirstKey?.()\n        );\n      }\n    } else if (!access3(mergedProps.isVirtualized)) {\n      const scrollEl = finalScrollRef();\n      if (scrollEl) {\n        scrollEl.scrollTop = scrollPos.top;\n        scrollEl.scrollLeft = scrollPos.left;\n        const element = scrollEl.querySelector(\n          `[data-key=\"${manager.focusedKey()}\"]`\n        );\n        if (element) {\n          focusWithoutScrolling(element);\n          scrollIntoView(scrollEl, element);\n        }\n      }\n    }\n  };\n  const onFocusOut = (e) => {\n    const manager = access3(mergedProps.selectionManager);\n    if (!e.currentTarget.contains(e.relatedTarget)) {\n      manager.setFocused(false);\n    }\n  };\n  const onMouseDown = (e) => {\n    if (finalScrollRef() === e.target) {\n      e.preventDefault();\n    }\n  };\n  const tryAutoFocus = () => {\n    const autoFocus = access3(mergedProps.autoFocus);\n    if (!autoFocus) {\n      return;\n    }\n    const manager = access3(mergedProps.selectionManager);\n    const delegate = access3(mergedProps.keyboardDelegate);\n    let focusedKey;\n    if (autoFocus === \"first\") {\n      focusedKey = delegate.getFirstKey?.();\n    }\n    if (autoFocus === \"last\") {\n      focusedKey = delegate.getLastKey?.();\n    }\n    const selectedKeys = manager.selectedKeys();\n    if (selectedKeys.size) {\n      focusedKey = selectedKeys.values().next().value;\n    }\n    manager.setFocused(true);\n    manager.setFocusedKey(focusedKey);\n    const refEl = ref();\n    if (refEl && focusedKey == null && !access3(mergedProps.shouldUseVirtualFocus)) {\n      focusWithoutScrolling(refEl);\n    }\n  };\n  onMount(() => {\n    if (mergedProps.deferAutoFocus) {\n      setTimeout(tryAutoFocus, 0);\n    } else {\n      tryAutoFocus();\n    }\n  });\n  createEffect2(\n    on(\n      [\n        finalScrollRef,\n        () => access3(mergedProps.isVirtualized),\n        () => access3(mergedProps.selectionManager).focusedKey()\n      ],\n      (newValue) => {\n        const [scrollEl, isVirtualized, focusedKey] = newValue;\n        if (isVirtualized) {\n          focusedKey && mergedProps.scrollToKey?.(focusedKey);\n        } else {\n          if (focusedKey && scrollEl) {\n            const element = scrollEl.querySelector(\n              `[data-key=\"${focusedKey}\"]`\n            );\n            if (element) {\n              scrollIntoView(scrollEl, element);\n            }\n          }\n        }\n      }\n    )\n  );\n  const tabIndex = createMemo2(() => {\n    if (access3(mergedProps.shouldUseVirtualFocus)) {\n      return void 0;\n    }\n    return access3(mergedProps.selectionManager).focusedKey() == null ? 0 : -1;\n  });\n  return {\n    tabIndex,\n    onKeyDown,\n    onMouseDown,\n    onFocusIn,\n    onFocusOut\n  };\n}\n\n// src/selection/create-selectable-item.ts\nimport { access as access4, focusWithoutScrolling as focusWithoutScrolling2 } from \"@kobalte/utils\";\nimport { createEffect as createEffect3, createMemo as createMemo3, on as on2 } from \"solid-js\";\nfunction createSelectableItem(props, ref) {\n  const manager = () => access4(props.selectionManager);\n  const key = () => access4(props.key);\n  const shouldUseVirtualFocus = () => access4(props.shouldUseVirtualFocus);\n  const onSelect = (e) => {\n    if (manager().selectionMode() === \"none\") {\n      return;\n    }\n    if (manager().selectionMode() === \"single\") {\n      if (manager().isSelected(key()) && !manager().disallowEmptySelection()) {\n        manager().toggleSelection(key());\n      } else {\n        manager().replaceSelection(key());\n      }\n    } else if (e?.shiftKey) {\n      manager().extendSelection(key());\n    } else if (manager().selectionBehavior() === \"toggle\" || isCtrlKeyPressed(e) || \"pointerType\" in e && e.pointerType === \"touch\") {\n      manager().toggleSelection(key());\n    } else {\n      manager().replaceSelection(key());\n    }\n  };\n  const isSelected = () => manager().isSelected(key());\n  const isDisabled = () => access4(props.disabled) || manager().isDisabled(key());\n  const allowsSelection = () => !isDisabled() && manager().canSelectItem(key());\n  let pointerDownType = null;\n  const onPointerDown = (e) => {\n    if (!allowsSelection()) {\n      return;\n    }\n    pointerDownType = e.pointerType;\n    if (e.pointerType === \"mouse\" && e.button === 0 && !access4(props.shouldSelectOnPressUp)) {\n      onSelect(e);\n    }\n  };\n  const onPointerUp = (e) => {\n    if (!allowsSelection()) {\n      return;\n    }\n    if (e.pointerType === \"mouse\" && e.button === 0 && access4(props.shouldSelectOnPressUp) && access4(props.allowsDifferentPressOrigin)) {\n      onSelect(e);\n    }\n  };\n  const onClick = (e) => {\n    if (!allowsSelection()) {\n      return;\n    }\n    if (access4(props.shouldSelectOnPressUp) && !access4(props.allowsDifferentPressOrigin) || pointerDownType !== \"mouse\") {\n      onSelect(e);\n    }\n  };\n  const onKeyDown = (e) => {\n    if (!allowsSelection() || ![\"Enter\", \" \"].includes(e.key)) {\n      return;\n    }\n    if (isNonContiguousSelectionModifier(e)) {\n      manager().toggleSelection(key());\n    } else {\n      onSelect(e);\n    }\n  };\n  const onMouseDown = (e) => {\n    if (isDisabled()) {\n      e.preventDefault();\n    }\n  };\n  const onFocus = (e) => {\n    const refEl = ref();\n    if (shouldUseVirtualFocus() || isDisabled() || !refEl) {\n      return;\n    }\n    if (e.target === refEl) {\n      manager().setFocusedKey(key());\n    }\n  };\n  const tabIndex = createMemo3(() => {\n    if (shouldUseVirtualFocus() || isDisabled()) {\n      return void 0;\n    }\n    return key() === manager().focusedKey() ? 0 : -1;\n  });\n  const dataKey = createMemo3(() => {\n    return access4(props.virtualized) ? void 0 : key();\n  });\n  createEffect3(\n    on2(\n      [\n        ref,\n        key,\n        shouldUseVirtualFocus,\n        () => manager().focusedKey(),\n        () => manager().isFocused()\n      ],\n      ([refEl, key2, shouldUseVirtualFocus2, focusedKey, isFocused]) => {\n        if (refEl && key2 === focusedKey && isFocused && !shouldUseVirtualFocus2 && document.activeElement !== refEl) {\n          if (props.focus) {\n            props.focus();\n          } else {\n            focusWithoutScrolling2(refEl);\n          }\n        }\n      }\n    )\n  );\n  return {\n    isSelected,\n    isDisabled,\n    allowsSelection,\n    tabIndex,\n    dataKey,\n    onPointerDown,\n    onPointerUp,\n    onClick,\n    onKeyDown,\n    onMouseDown,\n    onFocus\n  };\n}\n\n// src/selection/selection-manager.ts\nvar SelectionManager = class {\n  collection;\n  state;\n  constructor(collection, state) {\n    this.collection = collection;\n    this.state = state;\n  }\n  /** The type of selection that is allowed in the collection. */\n  selectionMode() {\n    return this.state.selectionMode();\n  }\n  /** Whether the collection allows empty selection. */\n  disallowEmptySelection() {\n    return this.state.disallowEmptySelection();\n  }\n  /** The selection behavior for the collection. */\n  selectionBehavior() {\n    return this.state.selectionBehavior();\n  }\n  /** Sets the selection behavior for the collection. */\n  setSelectionBehavior(selectionBehavior) {\n    this.state.setSelectionBehavior(selectionBehavior);\n  }\n  /** Whether the collection is currently focused. */\n  isFocused() {\n    return this.state.isFocused();\n  }\n  /** Sets whether the collection is focused. */\n  setFocused(isFocused) {\n    this.state.setFocused(isFocused);\n  }\n  /** The current focused key in the collection. */\n  focusedKey() {\n    return this.state.focusedKey();\n  }\n  /** Sets the focused key. */\n  setFocusedKey(key) {\n    if (key == null || this.collection().getItem(key)) {\n      this.state.setFocusedKey(key);\n    }\n  }\n  /** The currently selected keys in the collection. */\n  selectedKeys() {\n    return this.state.selectedKeys();\n  }\n  /** Returns whether a key is selected. */\n  isSelected(key) {\n    if (this.state.selectionMode() === \"none\") {\n      return false;\n    }\n    const retrievedKey = this.getKey(key);\n    if (retrievedKey == null) {\n      return false;\n    }\n    return this.state.selectedKeys().has(retrievedKey);\n  }\n  /** Whether the selection is empty. */\n  isEmpty() {\n    return this.state.selectedKeys().size === 0;\n  }\n  /** Whether all items in the collection are selected. */\n  isSelectAll() {\n    if (this.isEmpty()) {\n      return false;\n    }\n    const selectedKeys = this.state.selectedKeys();\n    return this.getAllSelectableKeys().every((k) => selectedKeys.has(k));\n  }\n  firstSelectedKey() {\n    let first;\n    for (const key of this.state.selectedKeys()) {\n      const item = this.collection().getItem(key);\n      const isItemBeforeFirst = item?.index != null && first?.index != null && item.index < first.index;\n      if (!first || isItemBeforeFirst) {\n        first = item;\n      }\n    }\n    return first?.key;\n  }\n  lastSelectedKey() {\n    let last;\n    for (const key of this.state.selectedKeys()) {\n      const item = this.collection().getItem(key);\n      const isItemAfterLast = item?.index != null && last?.index != null && item.index > last.index;\n      if (!last || isItemAfterLast) {\n        last = item;\n      }\n    }\n    return last?.key;\n  }\n  /** Extends the selection to the given key. */\n  extendSelection(toKey) {\n    if (this.selectionMode() === \"none\") {\n      return;\n    }\n    if (this.selectionMode() === \"single\") {\n      this.replaceSelection(toKey);\n      return;\n    }\n    const retrievedToKey = this.getKey(toKey);\n    if (retrievedToKey == null) {\n      return;\n    }\n    const selectedKeys = this.state.selectedKeys();\n    const anchorKey = selectedKeys.anchorKey || retrievedToKey;\n    const selection = new Selection(selectedKeys, anchorKey, retrievedToKey);\n    for (const key of this.getKeyRange(\n      anchorKey,\n      selectedKeys.currentKey || retrievedToKey\n    )) {\n      selection.delete(key);\n    }\n    for (const key of this.getKeyRange(retrievedToKey, anchorKey)) {\n      if (this.canSelectItem(key)) {\n        selection.add(key);\n      }\n    }\n    this.state.setSelectedKeys(selection);\n  }\n  getKeyRange(from, to) {\n    const fromItem = this.collection().getItem(from);\n    const toItem = this.collection().getItem(to);\n    if (fromItem && toItem) {\n      if (fromItem.index != null && toItem.index != null && fromItem.index <= toItem.index) {\n        return this.getKeyRangeInternal(from, to);\n      }\n      return this.getKeyRangeInternal(to, from);\n    }\n    return [];\n  }\n  getKeyRangeInternal(from, to) {\n    const keys = [];\n    let key = from;\n    while (key != null) {\n      const item = this.collection().getItem(key);\n      if (item && item.type === \"item\") {\n        keys.push(key);\n      }\n      if (key === to) {\n        return keys;\n      }\n      key = this.collection().getKeyAfter(key);\n    }\n    return [];\n  }\n  getKey(key) {\n    const item = this.collection().getItem(key);\n    if (!item) {\n      return key;\n    }\n    if (!item || item.type !== \"item\") {\n      return null;\n    }\n    return item.key;\n  }\n  /** Toggles whether the given key is selected. */\n  toggleSelection(key) {\n    if (this.selectionMode() === \"none\") {\n      return;\n    }\n    if (this.selectionMode() === \"single\" && !this.isSelected(key)) {\n      this.replaceSelection(key);\n      return;\n    }\n    const retrievedKey = this.getKey(key);\n    if (retrievedKey == null) {\n      return;\n    }\n    const keys = new Selection(this.state.selectedKeys());\n    if (keys.has(retrievedKey)) {\n      keys.delete(retrievedKey);\n    } else if (this.canSelectItem(retrievedKey)) {\n      keys.add(retrievedKey);\n      keys.anchorKey = retrievedKey;\n      keys.currentKey = retrievedKey;\n    }\n    if (this.disallowEmptySelection() && keys.size === 0) {\n      return;\n    }\n    this.state.setSelectedKeys(keys);\n  }\n  /** Replaces the selection with only the given key. */\n  replaceSelection(key) {\n    if (this.selectionMode() === \"none\") {\n      return;\n    }\n    const retrievedKey = this.getKey(key);\n    if (retrievedKey == null) {\n      return;\n    }\n    const selection = this.canSelectItem(retrievedKey) ? new Selection([retrievedKey], retrievedKey, retrievedKey) : new Selection();\n    this.state.setSelectedKeys(selection);\n  }\n  /** Replaces the selection with the given keys. */\n  setSelectedKeys(keys) {\n    if (this.selectionMode() === \"none\") {\n      return;\n    }\n    const selection = new Selection();\n    for (const key of keys) {\n      const retrievedKey = this.getKey(key);\n      if (retrievedKey != null) {\n        selection.add(retrievedKey);\n        if (this.selectionMode() === \"single\") {\n          break;\n        }\n      }\n    }\n    this.state.setSelectedKeys(selection);\n  }\n  /** Selects all items in the collection. */\n  selectAll() {\n    if (this.selectionMode() === \"multiple\") {\n      this.state.setSelectedKeys(new Set(this.getAllSelectableKeys()));\n    }\n  }\n  /**\n   * Removes all keys from the selection.\n   */\n  clearSelection() {\n    const selectedKeys = this.state.selectedKeys();\n    if (!this.disallowEmptySelection() && selectedKeys.size > 0) {\n      this.state.setSelectedKeys(new Selection());\n    }\n  }\n  /**\n   * Toggles between select all and an empty selection.\n   */\n  toggleSelectAll() {\n    if (this.isSelectAll()) {\n      this.clearSelection();\n    } else {\n      this.selectAll();\n    }\n  }\n  select(key, e) {\n    if (this.selectionMode() === \"none\") {\n      return;\n    }\n    if (this.selectionMode() === \"single\") {\n      if (this.isSelected(key) && !this.disallowEmptySelection()) {\n        this.toggleSelection(key);\n      } else {\n        this.replaceSelection(key);\n      }\n    } else if (this.selectionBehavior() === \"toggle\" || e && e.pointerType === \"touch\") {\n      this.toggleSelection(key);\n    } else {\n      this.replaceSelection(key);\n    }\n  }\n  /** Returns whether the current selection is equal to the given selection. */\n  isSelectionEqual(selection) {\n    if (selection === this.state.selectedKeys()) {\n      return true;\n    }\n    const selectedKeys = this.selectedKeys();\n    if (selection.size !== selectedKeys.size) {\n      return false;\n    }\n    for (const key of selection) {\n      if (!selectedKeys.has(key)) {\n        return false;\n      }\n    }\n    for (const key of selectedKeys) {\n      if (!selection.has(key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  canSelectItem(key) {\n    if (this.state.selectionMode() === \"none\") {\n      return false;\n    }\n    const item = this.collection().getItem(key);\n    return item != null && !item.disabled;\n  }\n  isDisabled(key) {\n    const item = this.collection().getItem(key);\n    return !item || item.disabled;\n  }\n  getAllSelectableKeys() {\n    const keys = [];\n    const addKeys = (key) => {\n      while (key != null) {\n        if (this.canSelectItem(key)) {\n          const item = this.collection().getItem(key);\n          if (!item) {\n            continue;\n          }\n          if (item.type === \"item\") {\n            keys.push(key);\n          }\n        }\n        key = this.collection().getKeyAfter(key);\n      }\n    };\n    addKeys(this.collection().getFirstKey());\n    return keys;\n  }\n};\n\n// src/list/list-collection.ts\nvar ListCollection = class {\n  keyMap = /* @__PURE__ */ new Map();\n  iterable;\n  firstKey;\n  lastKey;\n  constructor(nodes) {\n    this.iterable = nodes;\n    for (const node of nodes) {\n      this.keyMap.set(node.key, node);\n    }\n    if (this.keyMap.size === 0) {\n      return;\n    }\n    let last;\n    let index = 0;\n    for (const [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = void 0;\n      }\n      if (node.type === \"item\") {\n        node.index = index++;\n      }\n      last = node;\n      last.nextKey = void 0;\n    }\n    this.lastKey = last.key;\n  }\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n  getSize() {\n    return this.keyMap.size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    return this.keyMap.get(key)?.prevKey;\n  }\n  getKeyAfter(key) {\n    return this.keyMap.get(key)?.nextKey;\n  }\n  getFirstKey() {\n    return this.firstKey;\n  }\n  getLastKey() {\n    return this.lastKey;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n};\n\n// src/list/create-list-state.ts\nimport { access as access5 } from \"@kobalte/utils\";\nimport { createComputed } from \"solid-js\";\nfunction createListState(props) {\n  const selectionState = createMultipleSelectionState(props);\n  const factory = (nodes) => {\n    return props.filter ? new ListCollection(props.filter(nodes)) : new ListCollection(nodes);\n  };\n  const collection = createCollection(\n    {\n      dataSource: () => access5(props.dataSource),\n      getKey: () => access5(props.getKey),\n      getTextValue: () => access5(props.getTextValue),\n      getDisabled: () => access5(props.getDisabled),\n      getSectionChildren: () => access5(props.getSectionChildren),\n      factory\n    },\n    [() => props.filter]\n  );\n  const selectionManager = new SelectionManager(collection, selectionState);\n  createComputed(() => {\n    const focusedKey = selectionState.focusedKey();\n    if (focusedKey != null && !collection().getItem(focusedKey)) {\n      selectionState.setFocusedKey(void 0);\n    }\n  });\n  return {\n    collection,\n    selectionManager: () => selectionManager\n  };\n}\n\nexport {\n  Selection,\n  isSameSelection,\n  createMultipleSelectionState,\n  createTypeSelect,\n  createSelectableCollection,\n  createSelectableItem,\n  SelectionManager,\n  ListCollection,\n  createListState\n};\n"],"names":["makeEventListener","target","type","handler","options","tryOnCleanup","__name","createEventListener","targets","attachListeners","asArray","access","el","type2","createEffect","createRenderEffect","buildNodes","params","index","startIndex","level","startLevel","nodes","getKey","data","_getKey","dataKey","isString","String","getTextValue","_getTextValue","dataTextValue","getDisabled","_getDisabled","getSectionChildren","dataSource","isNumber","push","rawValue","key","textValue","disabled","sectionChildren","length","childNodes","createCollection","props","deps","createMemo","i","factory","Selection","_a","Set","anchorKey","currentKey","constructor","keys","_Selection","createControllableSelectionSignal","_value","setValue","createControllableSignal","value","isNonContiguousSelectionModifier","e","isAppleDevice","altKey","ctrlKey","isCtrlKeyPressed","isMac","metaKey","convertSelection","selection","isSameSelection","setA","setB","size","item","has","createMultipleSelectionState","mergedProps","mergeDefaultProps","selectionMode","selectionBehavior","isFocused","setFocused","createSignal","focusedKey","setFocusedKey","selectedKeysProp","selectedKeys","defaultSelectedKeys","defaultSelection","_setSelectedKeys","defaultValue","onChange","onSelectionChange","setSelectionBehavior","disallowEmptySelection","setSelectedKeys","allowDuplicateSelectionEvents","createTypeSelect","search","setSearch","createSignal2","timeoutId","setTimeoutId","typeSelectHandlers","onKeyDown","access2","isDisabled","delegate","keyboardDelegate","manager","selectionManager","getKeyForSearch","character","getStringForKey","trim","preventDefault","stopPropagation","newSearch","prev","isAllSameLetter","onTypeSelect","clearTimeout","window","setTimeout","test","split","every","letter","createSelectableCollection","ref","scrollRef","mergeProps","selectOnFocus","access3","finalScrollRef","direction","useLocale","scrollPos","top","left","isVirtualized","scrollEl","scrollTop","scrollLeft","disallowTypeAhead","orientation","callHandler","refEl","contains","navigateToKey","shiftKey","extendSelection","replaceSelection","shouldFocusWrap","getKeyBelow","nextKey","getFirstKey","getKeyAbove","getLastKey","getKeyLeftOf","isRTL","getKeyRightOf","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","disallowSelectAll","selectAll","defaultPrevented","clearSelection","allowsTabNavigation","focus","walker","getFocusableTreeWalker","tabbable","next","last","lastChild","document","activeElement","focusWithoutScrolling","onFocusIn","currentTarget","navigateToFirstKey","relatedTarget","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","querySelector","scrollIntoView","onFocusOut","onMouseDown","tryAutoFocus","autoFocus","values","shouldUseVirtualFocus","onMount","deferAutoFocus","createEffect2","on","newValue","scrollToKey","tabIndex","createMemo2","createSelectableItem","access4","onSelect","isSelected","toggleSelection","pointerType","allowsSelection","canSelectItem","pointerDownType","onPointerDown","button","shouldSelectOnPressUp","onPointerUp","allowsDifferentPressOrigin","onClick","includes","onFocus","createMemo3","virtualized","createEffect3","on2","key2","shouldUseVirtualFocus2","focusWithoutScrolling2","SelectionManager","collection","state","getItem","retrievedKey","isEmpty","isSelectAll","getAllSelectableKeys","k","first","isItemBeforeFirst","isItemAfterLast","toKey","retrievedToKey","getKeyRange","delete","add","from","to","fromItem","toItem","getKeyRangeInternal","getKeyAfter","toggleSelectAll","select","isSelectionEqual","addKeys","ListCollection","keyMap","Map","iterable","node","set","prevKey","Symbol","iterator","getSize","getKeys","getKeyBefore","get","at","idx","createListState","selectionState","access5","filter","createComputed"],"mappings":"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","x_google_ignoreList":[0,1,2]}