{"version":3,"file":"Uploader-f6bcb09a.js","sources":["../../src/uploadSocket.tsx","../../src/components/Uploader/Uploader.tsx"],"sourcesContent":["export let uploadServer = localStorage.getItem('uploadServer') ||\n  import.meta.env.PRIMAL_UPLOAD_URL;\n","import { Component, createEffect, createSignal, onCleanup, onMount, Show } from 'solid-js';\nimport { Progress } from '@kobalte/core/progress';\n\nimport styles from './Uploader.module.scss';\nimport { uploadServer } from '../../uploadSocket';\nimport { createStore } from 'solid-js/store';\nimport { NostrEOSE, NostrEvent, NostrEventContent, NostrEventType, NostrMediaUploaded } from '../../types/primal';\nimport { readUploadTime, saveUploadTime } from '../../lib/localStore';\nimport { startTimes, uploadMediaCancel, uploadMediaChunk, uploadMediaConfirm } from '../../lib/media';\nimport { sha256, uuidv4 } from '../../utils';\nimport { Kind, uploadLimit } from '../../constants';\nimport ButtonGhost from '../Buttons/ButtonGhost';\nimport { useAccountContext } from '../../contexts/AccountContext';\n\nconst MB = 1024 * 1024;\nconst maxParallelChunks = 5;\nlet chunkLimit = maxParallelChunks;\nconst maxChunkAttempts = 5;\n\ntype FileSize = 'small' | 'medium' | 'large' | 'huge' | 'final';\n\ntype UploadState = {\n  isUploading: boolean,\n  progress: number,\n  id?: string,\n  file?: File,\n  offset: number,\n  chunkSize: number,\n  chunkMap: number[],\n  uploadedChunks: number,\n  chunkIndex: number,\n  fileSize: FileSize,\n  uploadLimit: number,\n}\n\nconst Uploader: Component<{\n  publicKey?: string,\n  nip05?: string,\n  openSockets?: boolean,\n  hideLabel?: boolean,\n  file: File | undefined,\n  onFail?: (reason: string) => void,\n  onRefuse?: (reason: string) => void,\n  onCancel?: () => void,\n  onSuccsess?: (url: string) => void,\n}> = (props) => {\n  const account = useAccountContext();\n\n  const [uploadState, setUploadState] = createStore<UploadState>({\n    isUploading: false,\n    progress: 0,\n    offset: 0,\n    chunkSize: MB,\n    chunkMap: [],\n    uploadedChunks: 0,\n    chunkIndex: -1,\n    fileSize: 'small',\n    uploadLimit: uploadLimit.regular,\n  });\n\n  let sockets: WebSocket[] = [];\n  let uploadsInProgress: number[] = [];\n\n  let uploadChunkAttempts: number[] = Array(maxParallelChunks).fill(-1);\n\n  let initUploadTime = readUploadTime(props.publicKey);\n\n  let totalStart = 0;\n  let totalEnd = 0;\n\n  let times: number[] = [];\n  let subIdComplete = 'up_comp_';\n\n  let progressFill: HTMLDivElement | undefined;\n\n  let shouldCloseSockets = false;\n\n  createEffect(() => {\n    if (props.file !== undefined) {\n      uploadFile(props.file);\n    }\n    else {\n      resetUpload();\n    }\n  })\n\n  createEffect(() => {\n    if (props.openSockets) {\n      shouldCloseSockets = false;\n      for (let i=0; i < maxParallelChunks; i++) {\n        const socket = new WebSocket(uploadServer);\n\n        socket.addEventListener('close', () => {\n          if (shouldCloseSockets) return;\n\n          const newSocket = new WebSocket(uploadServer);\n\n          sockets[i] = newSocket;\n\n          const chunkIndex = uploadsInProgress[i];\n          if (chunkIndex > 0) {\n            uploadChunk(chunkIndex);\n          }\n        });\n\n        sockets.push(socket);\n      }\n    }\n    else {\n      shouldCloseSockets = true;\n      sockets.forEach(s => s.close());\n      sockets = [];\n    }\n  });\n\n  createEffect(() => {\n    calcUploadLimit(account?.membershipStatus.tier);\n  });\n\n  onCleanup(() => {\n    sockets.forEach(s => s.close());\n    sockets = [];\n  });\n\n  createEffect(() => {\n    if (uploadState.isUploading && uploadState.chunkIndex >= 0) {\n      uploadChunk(uploadState.chunkIndex);\n    }\n  });\n\n  const calcUploadLimit = (membershipTier: string | undefined) => {\n\n    if (membershipTier === 'premium') {\n      setUploadState('uploadLimit', () => uploadLimit.premium);\n      return;\n    }\n    if (membershipTier === 'premium-legend') {\n      setUploadState('uploadLimit', () => uploadLimit.premiumLegend);\n      return;\n    }\n\n    setUploadState('uploadLimit',  () => uploadLimit.regular);\n  };\n\n  const subTo = (socket: WebSocket, subId: string, cb: (type: NostrEventType, subId: string, content?: NostrEventContent) => void ) => {\n    const listener = (event: MessageEvent) => {\n      const message: NostrEvent | NostrEOSE = JSON.parse(event.data);\n      const [type, subscriptionId, content] = message;\n\n      if (subId === subscriptionId) {\n        cb(type, subscriptionId, content);\n      }\n\n    };\n\n    socket.addEventListener('message', listener);\n\n    return () => {\n      socket.removeEventListener('message', listener);\n    };\n  };\n\n  const resetUpload = (skipCancel?: boolean) => {\n    if (!skipCancel && uploadState.id) {\n      const soc = sockets[0];\n      uploadMediaCancel(props.publicKey, `up_c_${uploadState.id}`, uploadState.id || '', soc);\n    }\n\n    setUploadState(() => ({\n      isUploading: false,\n      file: undefined,\n      id: undefined,\n      progress: 0,\n      offset: 0,\n      chunkSize: MB,\n      chunkMap: [],\n      uploadedChunks: 0,\n      chunkIndex: -1,\n      fileSize: 'small',\n    }));\n\n    uploadChunkAttempts = Array(maxParallelChunks).fill(maxChunkAttempts);\n  };\n\n  const failUpload = () => {\n    resetUpload(true);\n    props.onFail && props.onFail('');\n  };\n\n  const onUploadCompleted = async (soc: WebSocket, file: File) => {\n    const sha = await sha256(file);\n\n    const unsubComplete = subTo(soc, subIdComplete, (type, subId, content) => {\n      if (type === 'NOTICE') {\n        unsubComplete();\n        failUpload();\n        return;\n      }\n\n      if (type === 'EVENT') {\n        if (!content) {\n          return;\n        }\n\n        if (content.kind === Kind.Uploaded) {\n          const up = content as NostrMediaUploaded;\n\n          totalEnd = Date.now();\n          const average = (totalEnd - totalStart) / uploadState.uploadedChunks;\n\n          saveUploadTime(props.publicKey, { [uploadState.fileSize]: average });\n\n          progressFill?.style.setProperty('--progress-rate', `${100}ms`);\n\n          setTimeout(() => {\n            setUploadState('progress', () => 100);\n          }, 10)\n\n\n          setTimeout(() => {\n            props.onSuccsess && props.onSuccsess(up.content);\n            resetUpload(true);\n          }, 500)\n          return;\n        }\n      }\n\n      if (type === 'EOSE') {\n        unsubComplete();\n        return;\n      }\n\n    });\n\n    uploadMediaConfirm(props.publicKey, subIdComplete, uploadState.id || '', file.size, sha, soc);\n  }\n\n\n  const uploadChunk = (index: number) => {\n    const { file, chunkSize, id, chunkMap } = uploadState;\n\n    const offset = chunkMap[index];\n\n    if (!file || !id) return;\n\n    const reader = new FileReader();\n\n    const nextOffset = offset + chunkSize;\n\n    let chunk = file.slice(offset, nextOffset);\n\n    reader.onload = (e) => {\n      if (!e.target?.result) {\n        return;\n      }\n\n      const subid = `up_${index}_${uploadChunkAttempts[index]}_${id}`;\n\n      const data = e.target?.result as string;\n\n      const socIndex = index % maxParallelChunks;\n\n      const soc = sockets[index % maxParallelChunks];\n\n      const unsub = subTo(soc, subid, (type, subId, content) => {\n\n        if (type === 'NOTICE') {\n          unsub();\n          if (uploadChunkAttempts[index] < 1) {\n            failUpload();\n            return;\n          }\n\n          uploadsInProgress[socIndex] = -1;\n          uploadChunkAttempts[index]--;\n          uploadChunk(index);\n          return;\n        }\n\n        if (type === 'EOSE') {\n          unsub();\n          uploadsInProgress[socIndex] = -1;\n\n          times[index] = Date.now() - startTimes[index];\n\n          if (!uploadState.isUploading) return;\n\n          setUploadState('uploadedChunks', n => n+1);\n\n          const len = chunkMap.length;\n\n          const progress = Math.ceil(100 * uploadState.uploadedChunks / uploadState.chunkMap.length) - 1;\n\n          setUploadState('progress', () => progress);\n\n          if (uploadState.uploadedChunks < len && uploadState.chunkIndex < len - 1) {\n            setUploadState('chunkIndex', i => i+1);\n            return;\n          }\n\n          if (uploadState.uploadedChunks === len) {\n            onUploadCompleted(soc, file);\n            return;\n          }\n\n        }\n      });\n\n      const rate = initUploadTime[uploadState.fileSize];\n      progressFill?.style.setProperty('--progress-rate', `${rate + rate / 4}ms`);\n\n      let fsize = file.size;\n\n      uploadsInProgress[socIndex] = index;\n\n      uploadMediaChunk(props.publicKey, subid, id, data, offset, fsize, soc, index);\n    }\n\n    reader.readAsDataURL(chunk);\n\n  };\n\n  const uploadFile = (file: File) => {\n    if (file.size >= MB * uploadState.uploadLimit) {\n      props.onRefuse && props.onRefuse(`file_too_big_${uploadState.uploadLimit}`);\n      resetUpload(true);\n      return;\n    }\n\n    let chunkSize = MB;\n    let fileSize: FileSize = 'huge';\n\n    if (file.size < MB / 2) {\n      chunkSize = file.size;\n      fileSize = 'small';\n    }\n    else if (file.size < MB) {\n      chunkSize = Math.ceil(MB / 4);\n      fileSize = 'medium';\n    }\n    else if (file.size < 12 * MB) {\n      chunkSize = Math.ceil(MB / 2);\n      fileSize = 'large';\n    }\n\n    let sum = 0;\n\n    let chunkMap: number[] = [];\n\n    while (sum < file.size) {\n      if (sum >= file.size) break;\n\n      chunkMap.push(sum);\n      sum += chunkSize;\n    }\n\n    setUploadState(() => ({\n      isUploading: true,\n      file,\n      id: uuidv4(),\n      progress: 0,\n      offset: 0,\n      chunkSize,\n      chunkMap,\n      chunkIndex: 0,\n      fileSize,\n    }))\n\n    subIdComplete = `up_comp_${uploadState.id}`;\n\n    uploadChunkAttempts = Array(chunkMap.length).fill(maxChunkAttempts);\n\n    chunkLimit = Math.min(maxParallelChunks, chunkMap.length - 2);\n\n    totalStart = Date.now();\n\n    for (let i=0;i < chunkLimit; i++) {\n      setTimeout(() => {\n        setUploadState('chunkIndex', () => i);\n      }, 0)\n    }\n  }\n\n  return (\n    <Show when={uploadState.id}>\n      <Progress value={uploadState.progress} class={styles.uploadProgress}>\n        <Show when={!props.hideLabel}>\n          <div class={styles.progressLabelContainer}>\n            <Progress.Label class={styles.progressLabel}>{uploadState.file?.name || ''}</Progress.Label>\n          </div>\n        </Show>\n        <div class={styles.progressTrackContainer}>\n          <Progress.Track class={styles.progressTrack}>\n            <Progress.Fill\n              ref={progressFill}\n              class={`${styles.progressFill} ${styles[uploadState.fileSize]}`}\n            />\n          </Progress.Track>\n\n          <ButtonGhost\n            onClick={() => {\n              resetUpload();\n              props.onCancel && props.onCancel();\n            }}\n            disabled={uploadState.progress > 100}\n          >\n            <Show\n              when={(uploadState.progress < 100)}\n              fallback={<div class={styles.iconCheck}></div>}\n            >\n              <div class={styles.iconClose}></div>\n            </Show>\n          </ButtonGhost>\n        </div>\n      </Progress>\n    </Show>\n  );\n}\n\nexport default Uploader;\n"],"names":["uploadServer","localStorage","getItem","import","MB","maxParallelChunks","chunkLimit","maxChunkAttempts","Uploader","props","account","useAccountContext","uploadState","setUploadState","createStore","isUploading","progress","offset","chunkSize","chunkMap","uploadedChunks","chunkIndex","fileSize","uploadLimit","regular","sockets","uploadsInProgress","uploadChunkAttempts","Array","fill","initUploadTime","readUploadTime","publicKey","totalStart","totalEnd","subIdComplete","progressFill","shouldCloseSockets","createEffect","file","undefined","uploadFile","resetUpload","openSockets","i","socket","WebSocket","addEventListener","newSocket","uploadChunk","push","forEach","s","close","calcUploadLimit","membershipStatus","tier","onCleanup","membershipTier","premium","premiumLegend","subTo","subId","cb","listener","event","message","JSON","parse","data","type","subscriptionId","content","removeEventListener","skipCancel","id","soc","uploadMediaCancel","failUpload","onFail","onUploadCompleted","__name","sha","sha256","unsubComplete","kind","Kind","Uploaded","up","Date","now","average","saveUploadTime","style","setProperty","setTimeout","onSuccsess","uploadMediaConfirm","size","index","reader","FileReader","nextOffset","chunk","slice","onload","e","target","result","subid","socIndex","unsub","n","len","length","Math","ceil","rate","fsize","uploadMediaChunk","readAsDataURL","onRefuse","sum","uuidv4","min","_$createComponent","Show","when","children","Progress","value","styles","uploadProgress","hideLabel","_el$","_tmpl$","_$insert","Label","progressLabel","name","_$effect","_$className","progressLabelContainer","_el$2","Track","progressTrack","Fill","ref","r$","_ref$","ButtonGhost","onClick","onCancel","disabled","fallback","_el$4","iconCheck","_el$3","iconClose","progressTrackContainer"],"mappings":"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"}