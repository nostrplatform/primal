{"version":3,"file":"5WXHJDCZ-8b9b8e69.js","sources":["../../node_modules/@solid-primitives/utils/dist/chunk/R5675YMU.js","../../node_modules/@solid-primitives/refs/dist/index.js","../../node_modules/@kobalte/core/dist/chunk/CWCB447F.jsx","../../node_modules/@kobalte/core/dist/chunk/E73PKFB3.jsx","../../node_modules/@kobalte/core/dist/chunk/5WXHJDCZ.jsx"],"sourcesContent":["import { DEV, equalFn, untrack, getOwner, onCleanup, createSignal, sharedConfig, onMount } from 'solid-js';\nimport { isServer } from 'solid-js/web';\nexport { isServer } from 'solid-js/web';\n\n// src/index.ts\nvar isClient = !isServer;\nvar isDev = isClient && !!DEV;\nvar isProd = !isDev;\nvar noop = () => void 0;\nvar trueFn = () => true;\nvar falseFn = () => false;\nvar defaultEquals = equalFn;\nvar EQUALS_FALSE_OPTIONS = { equals: false };\nvar INTERNAL_OPTIONS = { internal: true };\nvar ofClass = (v, c) => v instanceof c || v && v.constructor === c;\nfunction isObject(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nvar isNonNullable = (i) => i != null;\nvar filterNonNullable = (arr) => arr.filter(isNonNullable);\nvar compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nvar arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);\nfunction chain(callbacks) {\n  return (...args) => {\n    for (const callback of callbacks)\n      callback && callback(...args);\n  };\n}\nfunction reverseChain(callbacks) {\n  return (...args) => {\n    for (let i = callbacks.length - 1; i >= 0; i--) {\n      const callback = callbacks[i];\n      callback && callback(...args);\n    }\n  };\n}\nvar clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nvar access = (v) => typeof v === \"function\" && !v.length ? v() : v;\nvar asArray = (value) => Array.isArray(value) ? value : value ? [value] : [];\nvar accessArray = (list) => list.map((v) => access(v));\nvar withAccess = (value, fn) => {\n  const _value = access(value);\n  typeof _value != null && fn(_value);\n};\nvar asAccessor = (v) => typeof v === \"function\" ? v : () => v;\nfunction accessWith(valueOrFn, ...args) {\n  return typeof valueOrFn === \"function\" ? valueOrFn(...args) : valueOrFn;\n}\nfunction defer(deps, fn, initialValue) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let shouldDefer = true;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++)\n        input[i] = deps[i]();\n    } else\n      input = deps();\n    if (shouldDefer) {\n      shouldDefer = false;\n      prevInput = input;\n      return initialValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nvar entries = Object.entries;\nvar keys = Object.keys;\nvar tryOnCleanup = isDev ? (fn) => getOwner() ? onCleanup(fn) : fn : onCleanup;\nvar createCallbackStack = () => {\n  let stack = [];\n  const clear = () => stack = [];\n  return {\n    push: (...callbacks) => stack.push(...callbacks),\n    execute(arg0, arg1, arg2, arg3) {\n      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));\n      clear();\n    },\n    clear\n  };\n};\nfunction createMicrotask(fn) {\n  let calls = 0;\n  let args;\n  onCleanup(() => calls = 0);\n  return (...a) => {\n    args = a, calls++;\n    queueMicrotask(() => --calls === 0 && fn(...args));\n  };\n}\nfunction createHydratableSignal(serverValue, update, options) {\n  if (isServer) {\n    return createSignal(serverValue, options);\n  }\n  if (sharedConfig.context) {\n    const [state, setState] = createSignal(serverValue, options);\n    onMount(() => setState(() => update()));\n    return [state, setState];\n  }\n  return createSignal(update(), options);\n}\nvar createHydrateSignal = createHydratableSignal;\nfunction handleDiffArray(current, prev, handleAdded, handleRemoved) {\n  const currLength = current.length;\n  const prevLength = prev.length;\n  let i = 0;\n  if (!prevLength) {\n    for (; i < currLength; i++)\n      handleAdded(current[i]);\n    return;\n  }\n  if (!currLength) {\n    for (; i < prevLength; i++)\n      handleRemoved(prev[i]);\n    return;\n  }\n  for (; i < prevLength; i++) {\n    if (prev[i] !== current[i])\n      break;\n  }\n  let prevEl;\n  let currEl;\n  prev = prev.slice(i);\n  current = current.slice(i);\n  for (prevEl of prev) {\n    if (!current.includes(prevEl))\n      handleRemoved(prevEl);\n  }\n  for (currEl of current) {\n    if (!prev.includes(currEl))\n      handleAdded(currEl);\n  }\n}\n\nexport { EQUALS_FALSE_OPTIONS, INTERNAL_OPTIONS, access, accessArray, accessWith, arrayEquals, asAccessor, asArray, chain, clamp, compare, createCallbackStack, createHydratableSignal, createHydrateSignal, createMicrotask, defaultEquals, defer, entries, falseFn, filterNonNullable, handleDiffArray, isClient, isDev, isNonNullable, isObject, isProd, keys, noop, ofClass, reverseChain, trueFn, tryOnCleanup, withAccess };\n","import { chain, arrayEquals } from '@solid-primitives/utils';\nimport { createMemo, children, createComputed, untrack, onCleanup } from 'solid-js';\nimport { isServer } from 'solid-js/web';\n\n// src/index.ts\nfunction mergeRefs(...refs) {\n  return chain(refs);\n}\nvar defaultElementPredicate = isServer ? (item) => item != null && typeof item === \"object\" && \"t\" in item : (item) => item instanceof Element;\nfunction getResolvedElements(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getResolvedElements(value(), predicate);\n  if (Array.isArray(value)) {\n    const results = [];\n    for (const item of value) {\n      const result = getResolvedElements(item, predicate);\n      if (result)\n        Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results.length ? results : null;\n  }\n  return null;\n}\nfunction resolveElements(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  const memo = createMemo(\n    () => getResolvedElements(children2(), isServer ? serverPredicate : predicate)\n  );\n  memo.toArray = () => {\n    const value = memo();\n    return Array.isArray(value) ? value : value ? [value] : [];\n  };\n  return memo;\n}\nfunction getFirstChild(value, predicate) {\n  if (predicate(value))\n    return value;\n  if (typeof value === \"function\" && !value.length)\n    return getFirstChild(value(), predicate);\n  if (Array.isArray(value)) {\n    for (const item of value) {\n      const result = getFirstChild(item, predicate);\n      if (result)\n        return result;\n    }\n  }\n  return null;\n}\nfunction resolveFirst(fn, predicate = defaultElementPredicate, serverPredicate = defaultElementPredicate) {\n  const children2 = createMemo(fn);\n  return createMemo(() => getFirstChild(children2(), isServer ? serverPredicate : predicate));\n}\nfunction Refs(props) {\n  if (isServer) {\n    return props.children;\n  }\n  const cb = props.ref, resolved = children(() => props.children);\n  let prev = [];\n  createComputed(() => {\n    const els = resolved.toArray().filter(defaultElementPredicate);\n    if (!arrayEquals(prev, els))\n      untrack(() => cb(els));\n    prev = els;\n  }, []);\n  onCleanup(() => prev.length && cb([]));\n  return resolved;\n}\nfunction Ref(props) {\n  if (isServer) {\n    return props.children;\n  }\n  const cb = props.ref, resolved = children(() => props.children);\n  let prev;\n  createComputed(() => {\n    const el = resolved.toArray().find(defaultElementPredicate);\n    if (el !== prev)\n      untrack(() => cb(el));\n    prev = el;\n  });\n  onCleanup(() => prev && cb(void 0));\n  return resolved;\n}\n\nexport { Ref, Refs, defaultElementPredicate, getFirstChild, getResolvedElements, mergeRefs, resolveElements, resolveFirst };\n","// src/primitives/create-tag-name/create-tag-name.ts\nimport { isString } from \"@kobalte/utils\";\nimport { createEffect, createSignal } from \"solid-js\";\nfunction createTagName(ref, fallback) {\n  const [tagName, setTagName] = createSignal(stringOrUndefined(fallback?.()));\n  createEffect(() => {\n    setTagName(ref()?.tagName.toLowerCase() || stringOrUndefined(fallback?.()));\n  });\n  return tagName;\n}\nfunction stringOrUndefined(value) {\n  return isString(value) ? value : void 0;\n}\n\nexport {\n  createTagName\n};\n","// src/polymorphic/polymorphic.tsx\nimport { splitProps } from \"solid-js\";\nimport { Dynamic } from \"solid-js/web\";\nfunction Polymorphic(props) {\n  const [local, others] = splitProps(props, [\"as\"]);\n  if (!local.as) {\n    throw new Error(\n      \"[kobalte]: Polymorphic is missing the required `as` prop.\"\n    );\n  }\n  return (\n    // @ts-ignore: Props are valid but not worth calculating\n    <Dynamic component={local.as} {...others} />\n  );\n}\n\nexport {\n  Polymorphic\n};\n","var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\nexport {\n  __export\n};\n"],"names":["chain","callbacks","args","callback","__name","access","v","asArray","value","accessWith","valueOrFn","tryOnCleanup","onCleanup","mergeRefs","refs","defaultElementPredicate","item","getResolvedElements","predicate","results","result","resolveElements","fn","serverPredicate","children2","createMemo","memo","getFirstChild","resolveFirst","createTagName","ref","fallback","tagName","setTagName","createSignal","stringOrUndefined","createEffect","toLowerCase","isString","Polymorphic","props","local","others","splitProps","as","Error","_$createComponent","Dynamic","_$mergeProps","component","__defProp","Object","defineProperty","__export","target","all","name","get","enumerable"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}